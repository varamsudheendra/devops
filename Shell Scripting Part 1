My Super Detailed Shell Scripting Notes! üìù‚ú®

**(Based on "Shell Scripting for DevOps | Shell Scripting Zero 2 Hero")**

## 1. Diving into Shell Scripting & Automation ü§ñ

* **What is Automation?**
    * It's all about making tasks happen automatically, reducing the need for us to do them manually. Think of it as having a little helper for repetitive jobs! üë∑‚Äç‚ôÄÔ∏è
    * Especially crucial in a **Linux environment**, where we often have many machines or tasks to manage.
* **Why Shell Scripting?**
    * It's a powerful way to **automate repetitive and tedious tasks** on Linux machines.
    * These machines could be running in the cloud (like AWS EC2 instances) or local virtual machines (VMs).
    * **Examples:**
        * Imagine needing to print numbers from 1 to 1000 ‚Äì manually typing each one would be crazy! A script does it in seconds. üèÉ‚Äç‚ôÇÔ∏èüí®
        * Creating 1000 files for a test project? A script handles it, saving you tons of time and effort. üìÇüìÇüìÇ

---

## 2. Essential Linux Commands for Scripting üíª

Before we write scripts, we need to know the basic tools (commands)!

### A. Creating Files üìÅ

* `touch <filename>`:
    * **Purpose:** Used to create brand-new, empty files.
    * **Why it's important for automation:** You might need to generate many files automatically (e.g., log files, temporary configuration files). `touch` is super quick for this!
    * **Example:** `touch myfirstfile.txt` will create an empty file named `myfirstfile.txt`.
* `vim <filename>` or `vi <filename>`:
    * **Purpose:** This is a powerful text editor inside your Linux terminal. You can use it to create *and* open files to write content into them.
    * **Usage Flow:**
        1.  Type `vim <filename>` (e.g., `vim myscript.sh`).
        2.  You'll see the file opened in "command mode."
        3.  To start typing, press `i` (for **insert mode**). The bottom left will show `-- INSERT --`.
        4.  Type your content.
        5.  To save and exit: Press `Esc` (to go back to command mode), then type `:wq!` (write, quit, force) and press Enter.
        6.  To quit without saving: Press `Esc`, then type `:q!` and press Enter.

### B. Listing Files & Directories üìú

* `ls`:
    * **Purpose:** Lists all files and subdirectories in your current location. It's like looking inside a folder! üßê
    * **Example:** If you have `file1.txt`, `folderA`, `script.sh` in your current directory, `ls` will show them.
* `ls -ltr`:
    * **Purpose:** This is a more detailed way to list files.
        * `-l`: Long list format (shows permissions, owner, size, date).
        * `-t`: Sorts by modification time (newest first).
        * `-r`: Reverses the order (so it shows oldest first, or newest last if combined with `-t`).
    * **Benefit:** Helps you see when files were last changed, their permissions, and who owns them. Very useful for troubleshooting! üïµÔ∏è‚Äç‚ôÄÔ∏è

### C. Getting Help (Manual Pages) üìö

* `man <command>`:
    * **Purpose:** Displays the "manual page" for almost any Linux command. It's like a built-in help guide!
    * **Example:**
        * `man ls`: Shows all options and details for the `ls` command.
        * `man touch`: Explains how `touch` works.
    * **How to exit `man` page:** Press `q`.

### D. Viewing File Content üëÄ

* `cat <filename>`:
    * **Purpose:** Prints the entire content of a file directly to your terminal. Quick way to check what's inside a script or configuration file without opening it in an editor.
    * **Example:** `cat myscript.sh` will show all the lines of code in `myscript.sh`.

### E. Understanding Your Location üìç

* `pwd`:
    * **Purpose:** Stands for "Print Working Directory." It shows you the full path of the directory you are currently in.
    * **Example:** If you are in your home folder, `pwd` might output `/home/yourusername`.

### F. Managing Directories (Folders) üìÇ

* `mkdir <directory_name>`:
    * **Purpose:** "Make directory." Creates a new empty folder.
    * **Example:** `mkdir my_scripts` will create a new folder named `my_scripts`.
* `cd <directory_name>`:
    * **Purpose:** "Change directory." Moves you into a different folder.
    * **Examples:**
        * `cd my_scripts`: Moves you *into* the `my_scripts` folder.
        * `cd ..`: Moves you up one level (to the parent directory). If you were in `/home/user/my_scripts`, `cd ..` takes you to `/home/user`.
        * `cd ~`: Takes you directly to your home directory.

---

## 3. Your First Shell Script: Writing & Executing! üöÄ

This is where the magic happens!

### A. The Shebang Line (`#!`) üé©

* **What it is:** The very first line of every shell script. It looks like `#!/bin/bash` or `#!/bin/sh`.
* **Purpose:** It tells your operating system *which interpreter* should be used to run your script. Think of it as a crucial instruction for the computer.
* `#!/bin/bash`: This is generally preferred. It specifically tells the system to use the "Bash" shell interpreter.
* `#!/bin/sh`: This often points to a "symlink" (a shortcut) to another shell, which might be Bash or a simpler shell like Dash (especially on Ubuntu). Using `#!/bin/bash` makes sure your script always runs with Bash, which has more features.

### B. Printing Output (`echo`) üó£Ô∏è

* `echo "Hello World!"`:
    * **Purpose:** The simplest command in scripting! It prints whatever you tell it to the terminal screen. Great for messages, debugging, or showing results.
    * You can use single or double quotes, or no quotes for simple text. Double quotes are good if you have spaces or special characters.

### C. Let's Write a Script (using `vim`)! ‚úçÔ∏è

1.  **Create your script file:**
    * `vim myfirstscript.sh`
2.  **Enter Insert Mode:** Press `i`.
3.  **Add the content:**
    ```bash
    #!/bin/bash
    echo "Hello, Shell Scripting World!"
    echo "This is my very first script. Super exciting! üéâ"
    ```
4.  **Save and Exit:** Press `Esc`, then type `:wq!` and Enter.

### D. Making Your Script Executable (`chmod`) üîì

* **Problem:** By default, files you create are usually *not* executable. The system won't let you run them as programs.
* **Solution:** `chmod` (change mode) command.
    * **Purpose:** Used to change file permissions (read, write, execute) for different users.
    * **Permissions Explained (Numeric Mode - Super Important!):**
        * `4`: Read (r) - You can see the content.
        * `2`: Write (w) - You can modify the content.
        * `1`: Execute (x) - You can run it as a program/script.
        * These numbers are **added up** for combinations:
            * `7` = Read (4) + Write (2) + Execute (1) = All permissions.
            * `6` = Read (4) + Write (2) = Read and Write.
            * `5` = Read (4) + Execute (1) = Read and Execute.
    * **`chmod` Syntax:** `chmod <permission_number> <filename>`
    * **Example:**
        * `chmod 700 myfirstscript.sh`: Owner gets full (read, write, execute), no permissions for others.
        * `chmod 777 myfirstscript.sh`: Everyone gets full permissions (read, write, execute). (Be careful with 777 in production! ‚ö†Ô∏è)
        * `chmod +x myfirstscript.sh`: A simpler way to just add execute permission for the owner. This is often used.
* **Why it's important:** Your script won't run with `./` (see next point) until it has execute permission!

### E. Running Your Script! ‚ñ∂Ô∏è

Once your script has execute permission, you can run it in a few ways:

1.  `sh <script_name>`:
    * **Example:** `sh myfirstscript.sh`
    * **Note:** This explicitly tells the system to use the `sh` interpreter, *regardless* of your shebang line. So if your script needs Bash-specific features, this might cause issues if `sh` is linked to Dash.
2.  `./<script_name>`:
    * **Example:** `./myfirstscript.sh`
    * **Note:** This is the most common and recommended way to run scripts! The `./` means "run the script in the current directory." This method **respects your shebang line** (`#!/bin/bash`), ensuring the correct interpreter is used. ‚úÖ

### F. Adding Comments to Your Script üí¨

* `#` (Hash/Pound symbol):
    * **Purpose:** Any text after `#` on a line is ignored by the interpreter.
    * **Benefit:** Use comments to explain your code, make it easier to understand later, or temporarily disable a line without deleting it.
    * **Example:**
        ```bash
        #!/bin/bash
        # This script prints a welcome message.
        echo "Hello there!" # This line prints the greeting.
        ```

---

## 4. Shell Scripting in the DevOps World üåê

Shell scripting is NOT just for simple tasks; it's a backbone of DevOps!

* **Infrastructure Maintenance:** Automating system updates, backups, log rotation, cleaning up old files, and managing user accounts.
* **Code Management (with Git):** Creating scripts to automate Git commands (e.g., pulling latest code, running build steps, deploying).
* **Configuration Management:** Automating the setup and configuration of servers and applications (though tools like Ansible, Chef, Puppet are often used for larger scale, shell scripts handle smaller, specific tasks).
* **Real-world Example (John the DevOps Engineer):**
    * John works at Amazon. He's responsible for monitoring 10,000 Linux virtual machines! ü§Ø
    * Manually checking each one for CPU or memory usage would be impossible.
    * **Solution:** He uses **shell scripts**!
        * A script can run every few minutes on each VM.
        * It checks the CPU usage and memory usage.
        * If CPU goes above 90% or memory is critical, the script automatically sends an email alert to John. üìß
    * This is why shell scripting is a must-have skill for DevOps! It enables **proactive monitoring and automation at scale.**

---

## 5. Basic Commands for Node Health Monitoring üìä

These are the commands John's script might use:

* `nproc`:
    * **Purpose:** Shows the number of processing units (CPUs/cores) available to the current process.
    * **Example:** If your machine has 4 cores, `nproc` might output `4`.
* `free -h`:
    * **Purpose:** Displays the amount of free and used memory (RAM) in your system. The `-h` flag makes it "human-readable" (e.g., MB, GB).
    * **Benefit:** Quick check for memory bottlenecks.
* `top`:
    * **Purpose:** Provides a real-time, dynamic view of running processes. It shows CPU usage, memory usage, process IDs (PIDs), and much more.
    * **Benefit:** Great for identifying which processes are consuming the most resources.
    * **How to exit `top`:** Press `q`.
